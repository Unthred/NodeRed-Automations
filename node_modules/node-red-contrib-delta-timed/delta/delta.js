module.exports = function (RED) {
	'use strict'

	function pad(str, max) {
		str = str.toString();
		return str.length < max ? pad("0" + str, max) : str;
	}

	function delta(x, y) {
		if (typeof x === 'string') x = parseFloat(x);
		if (typeof y === 'string') y = parseFloat(y);
		if (typeof x === 'number' && typeof y === 'number') return y - x;
		if (Array.isArray(x) && Array.isArray(y)) {
			let result = [];
			let length = Math.min(x.length, y.length);
			for (let i = 0; i < length; i++) result.push(delta(x[i], y[i]));
			return result;
		}
		if (typeof x === 'object' && typeof y === 'object') {
			let result = {};
			Object.keys(y).forEach(function (k) {
				result[k] = delta(x[k], y[k]);
			})
			return result;
		}
		return null;
	}

	function DeltaNode(config) {
		RED.nodes.createNode(this, config);
		var node = this;
		node.topic = config.topic;
		node.status({});
		node.sum = 0;
		node.last = null;

		this.on("inInterval", function (time) {
			if (!node.activated) {
				node.activated = true;
				node.last = null
				node.delta = 0
				if (node.timeperiod.begin < node.timeperiod.end) node.timeperiod.begin.setDate(node.timeperiod.begin.getDate() + 1);
				node.status({ fill: "green", shape: "dot", text: Math.trunc((node.timeperiod.end - time) / 60000) + " min until deactivation" })
			}
		});

		this.on("outInterval", function (time) {
			if (node.activated) {
				node.activated = false;
				if (node.timeperiod.end < node.timeperiod.begin) node.timeperiod.end.setDate(node.timeperiod.end.getDate() + 1);
				node.status({ fill: "red", shape: "dot", text: Math.trunc((node.timeperiod.begin - time) / 60000) + " min until activation" })
			}
			node.send({ topic: node.topic, payload: node.delta, end: true })
		});

		this.on("interval_loop", function () {
			if (!node.activated) {
				node.activated = true;
				node.timeperiod.begin.setDate(node.timeperiod.begin.getDate() - 1)
				node.timeperiod.end.setDate(node.timeperiod.end.getDate() - 1)
				node.status({ fill: "blue", shape: "dot", text: "Loop : reset at " + pad(node.timeperiod.begin.getHours(), 2) + ":" + pad(node.timeperiod.begin.getMinutes(), 2) })
			}
			node.send({ topic: node.topic, payload: node.delta, reset: true });
			node.timeperiod.begin.setDate(node.timeperiod.begin.getDate() + 1);
			node.timeperiod.end.setDate(node.timeperiod.end.getDate() + 1);
			node.delta = 0;
			node.last = null;
		})

		this.on("interval_reached", function () {
			if (node.loop_emit) node.send({ topic: node.topic, payload: node.sum, loop: true });
			node.delta = 0
			node.last = null
		});

		node.timetype = config.timetype;
		node.threshold = config.threshold || null;
		node.activated = false;

		if (node.timetype === "interval") {
			node.interval = config.interval || 0;
			if (node.interval === 0) node.interval = 1;
			node.loop_emit = config.loop_emit;
			node.tick = setInterval(function () {
				node.emit("interval_reached", null)
			}, node.interval * 60000); // trigger every (interval) min
			node.activated = true;
			node.status({ fill: "blue", shape: "dot", text: "Interval mode" })
		} else if (node.timetype === "timeperiod") {
			node.timeperiod = {};
			node.timeperiod.begin = new Date();
			node.timeperiod.begin.setHours(config.timeperiod.begin.hour);
			node.timeperiod.begin.setMinutes(config.timeperiod.begin.minute);
			node.timeperiod.begin.setSeconds(0);
			node.timeperiod.end = new Date(node.timeperiod.begin);
			node.timeperiod.end.setHours(config.timeperiod.end.hour);
			node.timeperiod.end.setMinutes(config.timeperiod.end.minute);
			node.timeperiod.end.setSeconds(0);

			if (node.timeperiod.begin.getTime() === node.timeperiod.end.getTime()) { // if the node is defined as a loop
				node.emit("interval_loop", null);
			} else {
				//First, replace the in and out pointer
				if (node.timeperiod.begin >= node.timeperiod.end) node.timeperiod.begin.setDate(node.timeperiod.begin.getDate() - 1)
				// Then, check if we are in interval
				let time = new Date();
				if (time >= node.timeperiod.begin && time <= node.timeperiod.end) { // If we are in the interval
					node.emit("inInterval", time);
				} else { // if we are out
					if (time > node.timeperiod.end) { // if we are out, with time who exceed the timeperiod
						node.timeperiod.begin.setDate(node.timeperiod.begin.getDate() + 1);
						node.timeperiod.end.setDate(node.timeperiod.end.getDate() + 1)
					} // otherwise, do nothing
					node.activated = false;
					node.status({ fill: "red", shape: "dot", text: Math.floor((node.timeperiod.begin - time) / 60000) + " min until activation" })
				}
			}

			// Then, the node can start as wanted
			node.tick = setInterval(function () {
				node.emit("input", null)
			}, 60000); // trigger every 60 secs
		}

		this.on('input', function (msg) {
			let time = new Date();
			if (msg === null) {
				switch (node.timetype) {
					case "interval": {
						node.activated = true;
						break;
					}
					case "timeperiod": {
						if (node.activated && (node.timeperiod.begin.getTime() === node.timeperiod.end.getTime())) {
							if (time >= node.timeperiod.begin) {
								node.emit("interval_loop", null);
							}
							break;
						} else if (!node.activated && (node.timeperiod.begin <= time && node.timeperiod.end >= time)) {
							node.emit("inInterval", time);
						} else if (node.activated && time >= node.timeperiod.end) {
							node.emit("outInterval", time);
						} else if (node.activated) { // status update
							node.status({ fill: "green", shape: "dot", text: Math.trunc((node.timeperiod.end - time) / 60000) + " min until deactivation" })
						} else {
							node.status({ fill: "red", shape: "dot", text: Math.trunc((node.timeperiod.begin - time) / 60000) + " min until activation" })
						}
						break;
					}
					default: {
						break;
					}
				}
			} else { // if node received message
				let result = null;
				switch (node.timetype) {
					case "null": {
						if (node.last === null) {
							node.last = msg.payload;
							break;
						}
						result = delta(node.last, msg.payload);
						node.last = msg.payload;
						if (!(node.threshold !== null && result < node.threshold)) {
							node.send({ topic: node.topic, payload: result });
						}
						break;
					}
					default: {
						if (node.activated) {
							if (node.last === null) {
								node.last = msg.payload;
								node.delta = 0;
								return;
							}
							result = delta(node.last, msg.payload);
							node.last = msg.payload
							if (typeof result === "number") {
								node.delta += result;
							} else if (Array.isArray(result)) {
								for (let i = 0; i < result.length; i++)
									node.delta[i] += result[i];
							} else if (typeof result === 'object') {
								let keys = Object.keys(result);
								for (let i = 0; i < keys.length; i++)
									node.delta[keys[i]] += result[keys[i]];
							}

							if (!(node.threshold !== null && node.delta < node.threshold)) {
								if (!(node.timetype === "interval" && node.loop_emit))
									node.send({ topic: node.topic, payload: node.delta });
							}
						}
					}
				}
			}
		});

		node.on("close", function () {
			if (node.tick) {
				clearInterval(node.tick);
			}
		});
	}
	RED.nodes.registerType('delta', DeltaNode)
}
